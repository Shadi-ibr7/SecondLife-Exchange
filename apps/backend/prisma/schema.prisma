generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String              @id @default(cuid())
  email              String              @unique
  createdAt          DateTime            @default(now())
  avatarUrl          String?
  displayName        String
  passwordHash       String
  roles              UserRole            @default(USER)
  exchangesRequested Exchange[]          @relation("ExchangeRequester")
  exchangesResponded Exchange[]          @relation("ExchangeResponder")
  items              Item[]
  preferences        Preference?
  refreshTokens      RefreshToken[]
  profile            UserProfile?
  threads            Thread[]
  posts              Post[]
  notificationTokens NotificationToken[]
  chatMessages       ChatMessage[]       @relation("MessageSender")
  ban                Ban?
  adminLogs          AdminLog[]          @relation("AdminLogs")

  @@index([email])
  @@map("users")
}

model UserProfile {
  id              String  @id @default(cuid())
  userId          String  @unique
  bio             String?
  location        String?
  preferencesJson Json?
  user            User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

model Preference {
  userId              String   @id
  preferredCategories String[]
  dislikedCategories  String[]
  preferredConditions String[]
  locale              String?
  country             String?
  radiusKm            Int?
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("preferences")
}

model RefreshToken {
  id        String    @id @default(cuid())
  userId    String
  expiresAt DateTime
  createdAt DateTime  @default(now())
  revokedAt DateTime?
  tokenHash String    @unique
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tokenHash])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model Exchange {
  id                 String         @id @default(cuid())
  status             ExchangeStatus @default(PENDING)
  createdAt          DateTime       @default(now())
  completedAt        DateTime?
  offeredItemTitle   String
  requestedItemTitle String
  requesterId        String
  responderId        String
  message            String?
  requester          User           @relation("ExchangeRequester", fields: [requesterId], references: [id])
  responder          User           @relation("ExchangeResponder", fields: [responderId], references: [id])
  messages           ChatMessage[]

  @@index([requesterId])
  @@index([responderId])
  @@index([status])
  @@index([createdAt])
  @@map("exchanges")
}

model ChatMessage {
  id         String   @id @default(cuid())
  exchangeId String
  senderId   String
  content    String
  images     String[] // URLs des images
  createdAt  DateTime @default(now())
  exchange   Exchange @relation(fields: [exchangeId], references: [id], onDelete: Cascade)
  sender     User     @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([exchangeId])
  @@index([senderId])
  @@index([createdAt])
  @@map("chat_messages")
}

model Item {
  id              String        @id @default(cuid())
  ownerId         String
  title           String
  description     String
  category        ItemCategory
  condition       ItemCondition
  status          ItemStatus    @default(AVAILABLE)
  tags            String[]
  aiSummary       String?
  aiRepairTip     String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  popularityScore Int           @default(0)
  photos          ItemPhoto[]
  owner           User          @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  @@index([ownerId])
  @@index([category, condition, status])
  @@index([popularityScore])
  @@map("items")
}

model ItemPhoto {
  id        String   @id @default(cuid())
  itemId    String
  url       String
  publicId  String
  width     Int?
  height    Int?
  createdAt DateTime @default(now())
  item      Item     @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@index([itemId])
  @@map("item_photos")
}

model WeeklyTheme {
  id              String          @id @default(cuid())
  title           String
  slug            String          @unique
  startOfWeek     DateTime
  impactText      String?
  photoUrl        String? // URL de la photo depuis Unsplash
  photoUnsplashId String? // ID de la photo Unsplash pour attribution
  isActive        Boolean         @default(false)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  suggestions     SuggestedItem[]

  @@index([startOfWeek])
  @@index([isActive])
  @@map("weekly_themes")
}

model SuggestedItem {
  id               String      @id @default(cuid())
  themeId          String
  name             String
  category         String
  country          String
  era              String?
  materials        String?
  ecoReason        String?
  repairDifficulty String?
  popularity       Int?
  tags             String[]
  photoRef         String?
  aiModel          String?
  aiPromptHash     String?
  aiRaw            Json?
  createdAt        DateTime    @default(now())
  theme            WeeklyTheme @relation(fields: [themeId], references: [id], onDelete: Cascade)

  @@index([themeId, country])
  @@index([category])
  @@index([name])
  @@map("suggested_items")
}

model EcoContent {
  id          String    @id @default(cuid())
  kind        String
  title       String
  url         String
  locale      String?
  tags        String[]
  source      String?
  summary     String?
  kpis        Json?
  publishedAt DateTime?
  createdAt   DateTime  @default(now())

  @@index([kind])
  @@index([locale])
  @@index([tags])
  @@index([publishedAt])
  @@map("eco_content")
}

model Thread {
  id        String   @id @default(cuid())
  scope     String
  scopeRef  String?
  title     String
  authorId  String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  posts     Post[]

  @@index([scope, scopeRef])
  @@index([createdAt])
  @@map("threads")
}

model Post {
  id        String    @id @default(cuid())
  threadId  String
  authorId  String
  author    User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  content   String
  createdAt DateTime  @default(now())
  editedAt  DateTime?
  repliesTo String?
  parent    Post?     @relation("PostReplies", fields: [repliesTo], references: [id])
  replies   Post[]    @relation("PostReplies")
  thread    Thread    @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@index([threadId])
  @@index([createdAt])
  @@map("posts")
}

model NotificationToken {
  id        String   @id @default(cuid())
  userId    String
  provider  String
  token     String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
  @@index([userId])
  @@index([provider])
  @@map("notification_tokens")
}

enum UserRole {
  USER
  ADMIN
}

enum ExchangeStatus {
  PENDING
  ACCEPTED
  COMPLETED
  CANCELLED
  DECLINED
}

enum ItemCondition {
  NEW
  GOOD
  FAIR
  TO_REPAIR
}

enum ItemStatus {
  AVAILABLE
  PENDING
  TRADED
  ARCHIVED
}

enum ItemCategory {
  CLOTHING
  ELECTRONICS
  BOOKS
  HOME
  TOOLS
  TOYS
  SPORTS
  ART
  VINTAGE
  HANDCRAFT
  OTHER
}

model Ban {
  id        String   @id @default(cuid())
  userId    String   @unique
  reason    String?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("bans")
}

model Report {
  id               String    @id @default(cuid())
  type             String
  message          String
  targetUserId     String?
  targetItemId     String?
  targetExchangeId String?
  targetPostId     String?
  reporterId       String?
  createdAt        DateTime  @default(now())
  resolved         Boolean   @default(false)
  resolvedAt       DateTime?
  resolvedBy       String?

  @@index([targetUserId])
  @@index([targetItemId])
  @@index([resolved])
  @@index([createdAt])
  @@map("reports")
}

model AdminLog {
  id           String   @id @default(cuid())
  action       String
  resourceType String
  resourceId   String?
  adminId      String
  meta         Json?
  ip           String?
  userAgent    String?
  createdAt    DateTime @default(now())
  admin        User     @relation("AdminLogs", fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId])
  @@index([resourceType, resourceId])
  @@index([createdAt])
  @@map("admin_logs")
}
